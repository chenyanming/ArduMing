/**
 * PE6: attachInterrupt(6, dmpDataReady, RISING); // the 0 points correctly to INT6 / PE6
 */
#include "config.h"
#include "Kalman.h"
#define MPU6050_DMP_CODE_SIZE         1929    // the number of values for writing the dmpMemory[]
#define MPU6050_DMP_CONFIG_SIZE        192    // the number of values for writing the dmpConfig[]
#define MPU6050_DMP_UPDATES_SIZE        47    // the number of values for writing the dmpUpdates[]

// INTERRUPT FROM MPU-6000 DETECTION ROUTINE
volatile boolean mpuInterrupt = false;     // indicates whether MPU interrupt pin has gone high
void dmpDataReady() {
	mpuInterrupt = true;

}

float rpy_rol = 0;
float rpy_pit = 0;
float rpy_yaw = 0;

float GyroX = 0;
float GyroY = 0;
float GyroZ = 0;

//Kalman
Kalman kalmanX;
Kalman kalmanY;
Kalman kalmanZ;
uint32_t timer;
float kal_pit = 0;
float kal_rol = 0;
float kal_yaw = 0;

/* ================================================================================================ *\
 | Default MotionApps v2.0 42-byte FIFO packet structure (each value consists of 2 bytes):          |
 | -> this is array fifoBuffer[0-41]                                                                |
 |                                                                                                  |
 | [QUAT W][      ][QUAT X][      ][QUAT Y][      ][QUAT Z][      ][GYRO X][      ][GYRO Y][      ] |
 |   0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18  19  20  21  22  23  |
 |                                                                                                  |
 | [GYRO Z][      ][ACC X ][      ][ACC Y ][      ][ACC Z ][      ][      ]                         |
 |  24  25  26  27  28  29  30  31  32  33  34  35  36  37  38  39  40  41                          |
\ * =============================================================================================== */

// This array contains the default DMP memory bank binary that gets loaded during dmpInitialize().
// It was reconstructed from observed I2C traffic generated by the UC3-A3 demo code, and not extracted
// directly from that code. That is true of all transmissions in this sketch, and any documentation has
// been added after the fact by referencing the Invensense code.
// It gets written to volatile memory, so it has to be done at each start (it only takes ~1 second though).
const unsigned char dmpMemory[MPU6050_DMP_CODE_SIZE] PROGMEM = {
	// bank 0, 256 bytes
	0xFB, 0x00, 0x00, 0x3E, 0x00, 0x0B, 0x00, 0x36, 0x00, 0x01, 0x00, 0x02, 0x00, 0x03, 0x00, 0x00,
	0x00, 0x65, 0x00, 0x54, 0xFF, 0xEF, 0x00, 0x00, 0xFA, 0x80, 0x00, 0x0B, 0x12, 0x82, 0x00, 0x01,
	0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x28, 0x00, 0x00, 0xFF, 0xFF, 0x45, 0x81, 0xFF, 0xFF, 0xFA, 0x72, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x03, 0xE8, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x7F, 0xFF, 0xFF, 0xFE, 0x80, 0x01,
	0x00, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x3E, 0x03, 0x30, 0x40, 0x00, 0x00, 0x00, 0x02, 0xCA, 0xE3, 0x09, 0x3E, 0x80, 0x00, 0x00,
	0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00,
	0x41, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x0B, 0x2A, 0x00, 0x00, 0x16, 0x55, 0x00, 0x00, 0x21, 0x82,
	0xFD, 0x87, 0x26, 0x50, 0xFD, 0x80, 0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x05, 0x80, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00,
	0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x6F, 0x00, 0x02, 0x65, 0x32, 0x00, 0x00, 0x5E, 0xC0,
	0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFB, 0x8C, 0x6F, 0x5D, 0xFD, 0x5D, 0x08, 0xD9, 0x00, 0x7C, 0x73, 0x3B, 0x00, 0x6C, 0x12, 0xCC,
	0x32, 0x00, 0x13, 0x9D, 0x32, 0x00, 0xD0, 0xD6, 0x32, 0x00, 0x08, 0x00, 0x40, 0x00, 0x01, 0xF4,
	0xFF, 0xE6, 0x80, 0x79, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD0, 0xD6, 0x00, 0x00, 0x27, 0x10,

	// bank 1, 256 bytes
	0xFB, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00,
	0x00, 0x00, 0xFA, 0x36, 0xFF, 0xBC, 0x30, 0x8E, 0x00, 0x05, 0xFB, 0xF0, 0xFF, 0xD9, 0x5B, 0xC8,
	0xFF, 0xD0, 0x9A, 0xBE, 0x00, 0x00, 0x10, 0xA9, 0xFF, 0xF4, 0x1E, 0xB2, 0x00, 0xCE, 0xBB, 0xF7,
	0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x02, 0x00, 0x02, 0x02, 0x00, 0x00, 0x0C,
	0xFF, 0xC2, 0x80, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0xCF, 0x80, 0x00, 0x40, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x14,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x03, 0x3F, 0x68, 0xB6, 0x79, 0x35, 0x28, 0xBC, 0xC6, 0x7E, 0xD1, 0x6C,
	0x80, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB2, 0x6A, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0xF0, 0x00, 0x00, 0x00, 0x30,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x25, 0x4D, 0x00, 0x2F, 0x70, 0x6D, 0x00, 0x00, 0x05, 0xAE, 0x00, 0x0C, 0x02, 0xD0,

	// bank 2, 256 bytes
	0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0x00, 0x54, 0xFF, 0xEF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x01, 0x00, 0x00, 0x44, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x01, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0xFF, 0xEF, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
	0x00, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

	// bank 3, 256 bytes
	0xD8, 0xDC, 0xBA, 0xA2, 0xF1, 0xDE, 0xB2, 0xB8, 0xB4, 0xA8, 0x81, 0x91, 0xF7, 0x4A, 0x90, 0x7F,
	0x91, 0x6A, 0xF3, 0xF9, 0xDB, 0xA8, 0xF9, 0xB0, 0xBA, 0xA0, 0x80, 0xF2, 0xCE, 0x81, 0xF3, 0xC2,
	0xF1, 0xC1, 0xF2, 0xC3, 0xF3, 0xCC, 0xA2, 0xB2, 0x80, 0xF1, 0xC6, 0xD8, 0x80, 0xBA, 0xA7, 0xDF,
	0xDF, 0xDF, 0xF2, 0xA7, 0xC3, 0xCB, 0xC5, 0xB6, 0xF0, 0x87, 0xA2, 0x94, 0x24, 0x48, 0x70, 0x3C,
	0x95, 0x40, 0x68, 0x34, 0x58, 0x9B, 0x78, 0xA2, 0xF1, 0x83, 0x92, 0x2D, 0x55, 0x7D, 0xD8, 0xB1,
	0xB4, 0xB8, 0xA1, 0xD0, 0x91, 0x80, 0xF2, 0x70, 0xF3, 0x70, 0xF2, 0x7C, 0x80, 0xA8, 0xF1, 0x01,
	0xB0, 0x98, 0x87, 0xD9, 0x43, 0xD8, 0x86, 0xC9, 0x88, 0xBA, 0xA1, 0xF2, 0x0E, 0xB8, 0x97, 0x80,
	0xF1, 0xA9, 0xDF, 0xDF, 0xDF, 0xAA, 0xDF, 0xDF, 0xDF, 0xF2, 0xAA, 0xC5, 0xCD, 0xC7, 0xA9, 0x0C,
	0xC9, 0x2C, 0x97, 0x97, 0x97, 0x97, 0xF1, 0xA9, 0x89, 0x26, 0x46, 0x66, 0xB0, 0xB4, 0xBA, 0x80,
	0xAC, 0xDE, 0xF2, 0xCA, 0xF1, 0xB2, 0x8C, 0x02, 0xA9, 0xB6, 0x98, 0x00, 0x89, 0x0E, 0x16, 0x1E,
	0xB8, 0xA9, 0xB4, 0x99, 0x2C, 0x54, 0x7C, 0xB0, 0x8A, 0xA8, 0x96, 0x36, 0x56, 0x76, 0xF1, 0xB9,
	0xAF, 0xB4, 0xB0, 0x83, 0xC0, 0xB8, 0xA8, 0x97, 0x11, 0xB1, 0x8F, 0x98, 0xB9, 0xAF, 0xF0, 0x24,
	0x08, 0x44, 0x10, 0x64, 0x18, 0xF1, 0xA3, 0x29, 0x55, 0x7D, 0xAF, 0x83, 0xB5, 0x93, 0xAF, 0xF0,
	0x00, 0x28, 0x50, 0xF1, 0xA3, 0x86, 0x9F, 0x61, 0xA6, 0xDA, 0xDE, 0xDF, 0xD9, 0xFA, 0xA3, 0x86,
	0x96, 0xDB, 0x31, 0xA6, 0xD9, 0xF8, 0xDF, 0xBA, 0xA6, 0x8F, 0xC2, 0xC5, 0xC7, 0xB2, 0x8C, 0xC1,
	0xB8, 0xA2, 0xDF, 0xDF, 0xDF, 0xA3, 0xDF, 0xDF, 0xDF, 0xD8, 0xD8, 0xF1, 0xB8, 0xA8, 0xB2, 0x86,

	// bank 4, 256 bytes
	0xB4, 0x98, 0x0D, 0x35, 0x5D, 0xB8, 0xAA, 0x98, 0xB0, 0x87, 0x2D, 0x35, 0x3D, 0xB2, 0xB6, 0xBA,
	0xAF, 0x8C, 0x96, 0x19, 0x8F, 0x9F, 0xA7, 0x0E, 0x16, 0x1E, 0xB4, 0x9A, 0xB8, 0xAA, 0x87, 0x2C,
	0x54, 0x7C, 0xB9, 0xA3, 0xDE, 0xDF, 0xDF, 0xA3, 0xB1, 0x80, 0xF2, 0xC4, 0xCD, 0xC9, 0xF1, 0xB8,
	0xA9, 0xB4, 0x99, 0x83, 0x0D, 0x35, 0x5D, 0x89, 0xB9, 0xA3, 0x2D, 0x55, 0x7D, 0xB5, 0x93, 0xA3,
	0x0E, 0x16, 0x1E, 0xA9, 0x2C, 0x54, 0x7C, 0xB8, 0xB4, 0xB0, 0xF1, 0x97, 0x83, 0xA8, 0x11, 0x84,
	0xA5, 0x09, 0x98, 0xA3, 0x83, 0xF0, 0xDA, 0x24, 0x08, 0x44, 0x10, 0x64, 0x18, 0xD8, 0xF1, 0xA5,
	0x29, 0x55, 0x7D, 0xA5, 0x85, 0x95, 0x02, 0x1A, 0x2E, 0x3A, 0x56, 0x5A, 0x40, 0x48, 0xF9, 0xF3,
	0xA3, 0xD9, 0xF8, 0xF0, 0x98, 0x83, 0x24, 0x08, 0x44, 0x10, 0x64, 0x18, 0x97, 0x82, 0xA8, 0xF1,
	0x11, 0xF0, 0x98, 0xA2, 0x24, 0x08, 0x44, 0x10, 0x64, 0x18, 0xDA, 0xF3, 0xDE, 0xD8, 0x83, 0xA5,
	0x94, 0x01, 0xD9, 0xA3, 0x02, 0xF1, 0xA2, 0xC3, 0xC5, 0xC7, 0xD8, 0xF1, 0x84, 0x92, 0xA2, 0x4D,
	0xDA, 0x2A, 0xD8, 0x48, 0x69, 0xD9, 0x2A, 0xD8, 0x68, 0x55, 0xDA, 0x32, 0xD8, 0x50, 0x71, 0xD9,
	0x32, 0xD8, 0x70, 0x5D, 0xDA, 0x3A, 0xD8, 0x58, 0x79, 0xD9, 0x3A, 0xD8, 0x78, 0x93, 0xA3, 0x4D,
	0xDA, 0x2A, 0xD8, 0x48, 0x69, 0xD9, 0x2A, 0xD8, 0x68, 0x55, 0xDA, 0x32, 0xD8, 0x50, 0x71, 0xD9,
	0x32, 0xD8, 0x70, 0x5D, 0xDA, 0x3A, 0xD8, 0x58, 0x79, 0xD9, 0x3A, 0xD8, 0x78, 0xA8, 0x8A, 0x9A,
	0xF0, 0x28, 0x50, 0x78, 0x9E, 0xF3, 0x88, 0x18, 0xF1, 0x9F, 0x1D, 0x98, 0xA8, 0xD9, 0x08, 0xD8,
	0xC8, 0x9F, 0x12, 0x9E, 0xF3, 0x15, 0xA8, 0xDA, 0x12, 0x10, 0xD8, 0xF1, 0xAF, 0xC8, 0x97, 0x87,

	// bank 5, 256 bytes
	0x34, 0xB5, 0xB9, 0x94, 0xA4, 0x21, 0xF3, 0xD9, 0x22, 0xD8, 0xF2, 0x2D, 0xF3, 0xD9, 0x2A, 0xD8,
	0xF2, 0x35, 0xF3, 0xD9, 0x32, 0xD8, 0x81, 0xA4, 0x60, 0x60, 0x61, 0xD9, 0x61, 0xD8, 0x6C, 0x68,
	0x69, 0xD9, 0x69, 0xD8, 0x74, 0x70, 0x71, 0xD9, 0x71, 0xD8, 0xB1, 0xA3, 0x84, 0x19, 0x3D, 0x5D,
	0xA3, 0x83, 0x1A, 0x3E, 0x5E, 0x93, 0x10, 0x30, 0x81, 0x10, 0x11, 0xB8, 0xB0, 0xAF, 0x8F, 0x94,
	0xF2, 0xDA, 0x3E, 0xD8, 0xB4, 0x9A, 0xA8, 0x87, 0x29, 0xDA, 0xF8, 0xD8, 0x87, 0x9A, 0x35, 0xDA,
	0xF8, 0xD8, 0x87, 0x9A, 0x3D, 0xDA, 0xF8, 0xD8, 0xB1, 0xB9, 0xA4, 0x98, 0x85, 0x02, 0x2E, 0x56,
	0xA5, 0x81, 0x00, 0x0C, 0x14, 0xA3, 0x97, 0xB0, 0x8A, 0xF1, 0x2D, 0xD9, 0x28, 0xD8, 0x4D, 0xD9,
	0x48, 0xD8, 0x6D, 0xD9, 0x68, 0xD8, 0xB1, 0x84, 0x0D, 0xDA, 0x0E, 0xD8, 0xA3, 0x29, 0x83, 0xDA,
	0x2C, 0x0E, 0xD8, 0xA3, 0x84, 0x49, 0x83, 0xDA, 0x2C, 0x4C, 0x0E, 0xD8, 0xB8, 0xB0, 0xA8, 0x8A,
	0x9A, 0xF5, 0x20, 0xAA, 0xDA, 0xDF, 0xD8, 0xA8, 0x40, 0xAA, 0xD0, 0xDA, 0xDE, 0xD8, 0xA8, 0x60,
	0xAA, 0xDA, 0xD0, 0xDF, 0xD8, 0xF1, 0x97, 0x86, 0xA8, 0x31, 0x9B, 0x06, 0x99, 0x07, 0xAB, 0x97,
	0x28, 0x88, 0x9B, 0xF0, 0x0C, 0x20, 0x14, 0x40, 0xB8, 0xB0, 0xB4, 0xA8, 0x8C, 0x9C, 0xF0, 0x04,
	0x28, 0x51, 0x79, 0x1D, 0x30, 0x14, 0x38, 0xB2, 0x82, 0xAB, 0xD0, 0x98, 0x2C, 0x50, 0x50, 0x78,
	0x78, 0x9B, 0xF1, 0x1A, 0xB0, 0xF0, 0x8A, 0x9C, 0xA8, 0x29, 0x51, 0x79, 0x8B, 0x29, 0x51, 0x79,
	0x8A, 0x24, 0x70, 0x59, 0x8B, 0x20, 0x58, 0x71, 0x8A, 0x44, 0x69, 0x38, 0x8B, 0x39, 0x40, 0x68,
	0x8A, 0x64, 0x48, 0x31, 0x8B, 0x30, 0x49, 0x60, 0xA5, 0x88, 0x20, 0x09, 0x71, 0x58, 0x44, 0x68,

	// bank 6, 256 bytes
	0x11, 0x39, 0x64, 0x49, 0x30, 0x19, 0xF1, 0xAC, 0x00, 0x2C, 0x54, 0x7C, 0xF0, 0x8C, 0xA8, 0x04,
	0x28, 0x50, 0x78, 0xF1, 0x88, 0x97, 0x26, 0xA8, 0x59, 0x98, 0xAC, 0x8C, 0x02, 0x26, 0x46, 0x66,
	0xF0, 0x89, 0x9C, 0xA8, 0x29, 0x51, 0x79, 0x24, 0x70, 0x59, 0x44, 0x69, 0x38, 0x64, 0x48, 0x31,
	0xA9, 0x88, 0x09, 0x20, 0x59, 0x70, 0xAB, 0x11, 0x38, 0x40, 0x69, 0xA8, 0x19, 0x31, 0x48, 0x60,
	0x8C, 0xA8, 0x3C, 0x41, 0x5C, 0x20, 0x7C, 0x00, 0xF1, 0x87, 0x98, 0x19, 0x86, 0xA8, 0x6E, 0x76,
	0x7E, 0xA9, 0x99, 0x88, 0x2D, 0x55, 0x7D, 0x9E, 0xB9, 0xA3, 0x8A, 0x22, 0x8A, 0x6E, 0x8A, 0x56,
	0x8A, 0x5E, 0x9F, 0xB1, 0x83, 0x06, 0x26, 0x46, 0x66, 0x0E, 0x2E, 0x4E, 0x6E, 0x9D, 0xB8, 0xAD,
	0x00, 0x2C, 0x54, 0x7C, 0xF2, 0xB1, 0x8C, 0xB4, 0x99, 0xB9, 0xA3, 0x2D, 0x55, 0x7D, 0x81, 0x91,
	0xAC, 0x38, 0xAD, 0x3A, 0xB5, 0x83, 0x91, 0xAC, 0x2D, 0xD9, 0x28, 0xD8, 0x4D, 0xD9, 0x48, 0xD8,
	0x6D, 0xD9, 0x68, 0xD8, 0x8C, 0x9D, 0xAE, 0x29, 0xD9, 0x04, 0xAE, 0xD8, 0x51, 0xD9, 0x04, 0xAE,
	0xD8, 0x79, 0xD9, 0x04, 0xD8, 0x81, 0xF3, 0x9D, 0xAD, 0x00, 0x8D, 0xAE, 0x19, 0x81, 0xAD, 0xD9,
	0x01, 0xD8, 0xF2, 0xAE, 0xDA, 0x26, 0xD8, 0x8E, 0x91, 0x29, 0x83, 0xA7, 0xD9, 0xAD, 0xAD, 0xAD,
	0xAD, 0xF3, 0x2A, 0xD8, 0xD8, 0xF1, 0xB0, 0xAC, 0x89, 0x91, 0x3E, 0x5E, 0x76, 0xF3, 0xAC, 0x2E,
	0x2E, 0xF1, 0xB1, 0x8C, 0x5A, 0x9C, 0xAC, 0x2C, 0x28, 0x28, 0x28, 0x9C, 0xAC, 0x30, 0x18, 0xA8,
	0x98, 0x81, 0x28, 0x34, 0x3C, 0x97, 0x24, 0xA7, 0x28, 0x34, 0x3C, 0x9C, 0x24, 0xF2, 0xB0, 0x89,
	0xAC, 0x91, 0x2C, 0x4C, 0x6C, 0x8A, 0x9B, 0x2D, 0xD9, 0xD8, 0xD8, 0x51, 0xD9, 0xD8, 0xD8, 0x79,

	// bank 7, 137 bytes (remainder)
	0xD9, 0xD8, 0xD8, 0xF1, 0x9E, 0x88, 0xA3, 0x31, 0xDA, 0xD8, 0xD8, 0x91, 0x2D, 0xD9, 0x28, 0xD8,
	0x4D, 0xD9, 0x48, 0xD8, 0x6D, 0xD9, 0x68, 0xD8, 0xB1, 0x83, 0x93, 0x35, 0x3D, 0x80, 0x25, 0xDA,
	0xD8, 0xD8, 0x85, 0x69, 0xDA, 0xD8, 0xD8, 0xB4, 0x93, 0x81, 0xA3, 0x28, 0x34, 0x3C, 0xF3, 0xAB,
	0x8B, 0xF8, 0xA3, 0x91, 0xB6, 0x09, 0xB4, 0xD9, 0xAB, 0xDE, 0xFA, 0xB0, 0x87, 0x9C, 0xB9, 0xA3,
	0xDD, 0xF1, 0xA3, 0xA3, 0xA3, 0xA3, 0x95, 0xF1, 0xA3, 0xA3, 0xA3, 0x9D, 0xF1, 0xA3, 0xA3, 0xA3,
	0xA3, 0xF2, 0xA3, 0xB4, 0x90, 0x80, 0xF2, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3,
	0xA3, 0xB2, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xB0, 0x87, 0xB5, 0x99, 0xF1, 0xA3, 0xA3, 0xA3,
	0x98, 0xF1, 0xA3, 0xA3, 0xA3, 0xA3, 0x97, 0xA3, 0xA3, 0xA3, 0xA3, 0xF3, 0x9B, 0xA3, 0xA3, 0xDC,
	0xB9, 0xA7, 0xF1, 0x26, 0x26, 0x26, 0xD8, 0xD8, 0xFF
};

// This array contains the DMP configurations that gets loaded during dmpInitialize().
// thanks to Noah Zerkin for piecing this stuff together!
const unsigned char dmpConfig[MPU6050_DMP_CONFIG_SIZE] PROGMEM = {
//  BANK    OFFSET  LENGTH  [DATA]
	0x03,   0x7B,   0x03,   0x4C, 0xCD, 0x6C,                   // FCFG_1 inv_set_gyro_calibration
	0x03,   0xAB,   0x03,   0x36, 0x56, 0x76,                   // FCFG_3 inv_set_gyro_calibration
	0x00,   0x68,   0x04,   0x02, 0xCB, 0x47, 0xA2,             // D_0_104 inv_set_gyro_calibration
	0x02,   0x18,   0x04,   0x00, 0x05, 0x8B, 0xC1,             // D_0_24 inv_set_gyro_calibration
	0x01,   0x0C,   0x04,   0x00, 0x00, 0x00, 0x00,             // D_1_152 inv_set_accel_calibration
	0x03,   0x7F,   0x06,   0x0C, 0xC9, 0x2C, 0x97, 0x97, 0x97, // FCFG_2 inv_set_accel_calibration
	0x03,   0x89,   0x03,   0x26, 0x46, 0x66,                   // FCFG_7 inv_set_accel_calibration
	0x00,   0x6C,   0x02,   0x20, 0x00,                         // D_0_108 inv_set_accel_calibration
	0x02,   0x40,   0x04,   0x00, 0x00, 0x00, 0x00,             // CPASS_MTX_00 inv_set_compass_calibration
	0x02,   0x44,   0x04,   0x00, 0x00, 0x00, 0x00,             // CPASS_MTX_01
	0x02,   0x48,   0x04,   0x00, 0x00, 0x00, 0x00,             // CPASS_MTX_02
	0x02,   0x4C,   0x04,   0x00, 0x00, 0x00, 0x00,             // CPASS_MTX_10
	0x02,   0x50,   0x04,   0x00, 0x00, 0x00, 0x00,             // CPASS_MTX_11
	0x02,   0x54,   0x04,   0x00, 0x00, 0x00, 0x00,             // CPASS_MTX_12
	0x02,   0x58,   0x04,   0x00, 0x00, 0x00, 0x00,             // CPASS_MTX_20
	0x02,   0x5C,   0x04,   0x00, 0x00, 0x00, 0x00,             // CPASS_MTX_21
	0x02,   0xBC,   0x04,   0x00, 0x00, 0x00, 0x00,             // CPASS_MTX_22
	0x01,   0xEC,   0x04,   0x00, 0x00, 0x40, 0x00,             // D_1_236 inv_apply_endian_accel
	0x03,   0x7F,   0x06,   0x0C, 0xC9, 0x2C, 0x97, 0x97, 0x97, // FCFG_2 inv_set_mpu_sensors
	0x04,   0x02,   0x03,   0x0D, 0x35, 0x5D,                   // CFG_MOTION_BIAS inv_turn_on_bias_from_no_motion
	0x04,   0x09,   0x04,   0x87, 0x2D, 0x35, 0x3D,             // FCFG_5 inv_set_bias_update
	0x00,   0xA3,   0x01,   0x00,                               // D_0_163 inv_set_dead_zone
	// SPECIAL 0x01 = enable interrupts
	0x00,   0x00,   0x00,   0x01, // SET INT_ENABLE at i=22, SPECIAL INSTRUCTION
	0x07,   0x86,   0x01,   0xFE,                               // CFG_6 inv_set_fifo_interupt
	0x07,   0x41,   0x05,   0xF1, 0x20, 0x28, 0x30, 0x38,       // CFG_8 inv_send_quaternion
	0x07,   0x7E,   0x01,   0x30,                               // CFG_16 inv_set_footer
	0x07,   0x46,   0x01,   0x9A,                               // CFG_GYRO_SOURCE inv_send_gyro
	0x07,   0x47,   0x04,   0xF1, 0x28, 0x30, 0x38,             // CFG_9 inv_send_gyro -> inv_construct3_fifo
	0x07,   0x6C,   0x04,   0xF1, 0x28, 0x30, 0x38,             // CFG_12 inv_send_accel -> inv_construct3_fifo
	0x02,   0x16,   0x02,   0x00, 0x01                          // D_0_22 inv_set_fifo_rate

	// This very last 0x01 WAS a 0x09, which drops the FIFO rate down to 20 Hz. 0x07 is 25 Hz,
	// 0x01 is 100 Hz. Going faster than 100 Hz (0x00 = 200 Hz) tends to result in very noisy data.
	// DMP output frequency is calculated easily using this equation: (200 Hz / (1 + value)).

	// It is important to make sure the host processor can keep up with reading and processing
	// the FIFO output at the desired rate. Handling FIFO overflow cleanly is also a good idea.
};

// This array contains the DMP updates that get loaded during dmpInitialize().
const unsigned char dmpUpdates[MPU6050_DMP_UPDATES_SIZE] PROGMEM = {
	0x01,   0xB2,   0x02,   0xFF, 0xFF,
	0x01,   0x90,   0x04,   0x09, 0x23, 0xA1, 0x35,
	0x01,   0x6A,   0x02,   0x06, 0x00,
	0x01,   0x60,   0x08,   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00,   0x60,   0x04,   0x40, 0x00, 0x00, 0x00,
	0x01,   0x62,   0x02,   0x00, 0x00,
	0x00,   0x60,   0x04,   0x00, 0x40, 0x00, 0x00
};

// MPU control & status variables
boolean dmpReady = false;     // set true if DMP initialization was successful
unsigned int packetSize = 42; // number of unique bytes of data written by the DMP each time (FIFO can hold multiples of 42-bytes)
unsigned int fifoCount;       // count of all bytes currently in FIFO
byte fifoBuffer[64];          // FIFO storage buffer (in fact only 42 used...) // But in datasheet, fifo has 1024bytes and FIFO count may be large...

// packet structure for InvenSense Teapot demo
byte teapotPacket[14] = { '$', 0x02, 0, 0, 0, 0, 0, 0, 0, 0, 0x00, 0x00, '\r', '\n' };




// ############################################################################################## //
// ################################ DMP functions used in dmpInitialize() ####################### //
// ############################################################################################## //
// If you like to know how it works, please read on. Otherwise, just FIRE AND FORGET ;-)



// static volatile bool spi0_transferflag = false;


// --- Function for SPI writing one byte to sensor
// reg        : MPU-6000 register number to write to
// data       : data to be written into reg
// ChipSelPin : MPU-6000 chip select pin number (in this sketch defined by ChipSelPin1)
// return     > nothing
void spi_writeReg(int ChipSelPin, unsigned char reg, unsigned char data) {
	byte dump;
	digitalWrite(ChipSelPin, LOW);
	dump = SPI.transfer(reg);
	dump = SPI.transfer(data);
	digitalWrite(ChipSelPin, HIGH);
}

// --- Function for SPI reading one byte from sensor
// reg        : MPU-6000 register number to read from
// ChipSelPin : MPU-6000 chip select pin number (in this sketch defined by ChipSelPin1)
// return     > register contents

// --- Function for SPI reading one bit from sensor
// reg        : MPU-6000 register number to read from
// bitNum     : bit number in the register to read - 7 (MSB) to 0 (LSB)
// ChipSelPin : MPU-6000 chip select pin number (in this sketch defined by ChipSelPin1)
// return     > byte 0x00 if bit is 0, otherwise byte with a 1 at bitNum (rest 0's)

//--- Function for SPI reading multiple bits from sensor
// reg        : MPU-6000 register number to read from
// ChipSelPin : MPU-6000 chip select pin number (in this sketch defined by ChipSelPin1)
// return     > databits
//
// 01101001 read byte
// 76543210 bit numbers
//    xxx   bitStart = 4, length = 3
//    010   masked
//   -> 010 shifted
unsigned char spi_readReg(int ChipSelPin, unsigned char reg) {
	byte dump;
	digitalWrite(ChipSelPin, LOW);     // select MPU-6000 for SPI transfer (low active)
	dump = SPI.transfer(reg | 0x80);          // reg | 0x80 causes a "1" added as MSB to reg to denote reading from reg i.s.o. writing to it
	byte read_value = SPI.transfer(0x00); // write 8-bits zero to MPU-6000, read the 8-bits coming back from reg at the same time
	digitalWrite(ChipSelPin, HIGH);    // deselect MPU-6000 for SPI transfer
	return read_value;

}

//--- Function for SPI writing one bit to sensor
// reg        : MPU-6000 register number to write to
// bitNum     : bit number in the register to write to - 7 (MSB) to 0 (LSB)
// databit    : bit value to be written into reg - false or 0 | true or non-zero (1 will be logical)
// ChipSelPin : MPU-6000 chip select pin number (in this sketch defined by ChipSelPin1)
// return     > nothing
//
// first read byte, then insert bit value, then write byte:
// otherwise all other bits will be written 0, this may trigger unexpected behaviour


//--- Function for SPI writing multiple bits to sensor
// reg        : MPU-6000 register number to write to
// ChipSelPin : MPU-6000 chip select pin number (in this sketch defined by ChipSelPin1)
//
// bbbbb010 -> data (bits to write - leading 0's)
// 76543210 bit numbers
//    xxx   bitStart = 4, length = 3
// 00011100 mask byte
// 10101111 original reg value (read)
// 10100011 original reg value & ~mask
// 10101011 masked | original reg value
//
// first read byte, then insert bit values, then write byte:
// otherwise all other bits will be written 0, this may trigger unexpected behaviour
void spi_SetBits(int ChipSelPin, unsigned char reg, unsigned char mask) {
	byte rev = spi_readReg(ChipSelPin1, reg);
	rev |= (mask);
	spi_writeReg(ChipSelPin1, reg, rev);
}

void spi_ClrBits(int ChipSelPin, unsigned char reg, unsigned char mask) {
	byte rev = spi_readReg(ChipSelPin1, reg);
	rev &= ~(mask);
	spi_writeReg(ChipSelPin1, reg, rev);
}

//--- Function for SPI reading multiple bytes to sensor
// read multiple bytes from the same device register, most of the times this
// is the FIFO transfer register (which after each read, is automatically
// loaded with new data for the next read)
// reg        : MPU-6000 register number to write to
// length     : number of bytes to be read
// data       : buffer array (starting with [0]) to store the read data in
// ChipSelPin : MPU-6000 chip select pin number (in this sketch defined by ChipSelPin1)
// return     > array of data[0 - length]
void spi_readBytes(int ChipSelPin, byte reg, unsigned int length, byte *data) {
	digitalWrite(ChipSelPin, LOW);
	//After experiment, no need to delay
	// delay(10); // wait 10 ms for MPU-6000 to react on chipselect (if this is 4 ms or less, SPI.transfer fails)
	SPI.transfer(reg | 0x80); // reg | 0x80 causes a "1" added as MSB to reg to denote reading from reg i.s.o. writing to it

	unsigned int count = 0;
	byte data_bytes_printed = 0;

	for (count = 0; count < length; count ++)
	{
		data[count] = SPI.transfer(0x00);
	}

	digitalWrite(ChipSelPin, HIGH);
	// DEBUG_PRINTLN(" (done)");
}


//***********************************************************//
boolean writeDMPMemory()
{
	// - the value in 0x6D activates a specific bank in the DMP
	// - the value in 0x6E sets the read/write pointer to a specific startaddress within the specified DMP bank
	// - register 0x6F is the register from which to read or to which to write the data
	//   (after each r/w autoincrement address within the specified DMP bank starting from startaddress)

	// Serial.print("\tWriting   DMP memory.......... ");

	unsigned int i, j;
	byte dmp_byte;

	// ### there are 8 DMP banks (numbers 0 to 7)

	// DMP banks 0 - 6 are completely filled with 256 bytes:
	for (i = 0; i < 7; i ++)
	{
		DEBUG_PRINT("@@@ write bank "); DEBUG_PRINTLN(i);
		spi_writeReg(ChipSelPin1, 0x6D, i); // bank number  = i
		spi_writeReg(ChipSelPin1, 0x6E, 0);       // startaddress = 0 so start writing every DMP bank from the beginning
		digitalWrite(ChipSelPin1, LOW);
		SPI.transfer(0x6F);

		for (j = 0; j < 256; j ++) // max. 256 bytes of data fit into one DMP bank
		{
			dmp_byte = pgm_read_byte(dmpMemory + (i * 256) + j);
			SPI.transfer(dmp_byte);
		}
		digitalWrite(ChipSelPin1, HIGH);
		// DEBUG_PRINTLN();
	}

	// DMP bank 7 gets only 137 bytes:
	DEBUG_PRINTLN("@@@ write bank 7");
	spi_writeReg(ChipSelPin1, 0x6D, 7); // bank number  = 7
	spi_writeReg(ChipSelPin1, 0x6E, 0);       // startaddress = 0 so start writing also this DMP bank from the beginning
	digitalWrite(ChipSelPin1, LOW);
	SPI.transfer(0x6F);

	for (j = 0; j < 137; j ++) // only 137 bytes of data into DMP bank 7
	{
		dmp_byte = pgm_read_byte(dmpMemory + (7 * 256) + j);
		SPI.transfer(dmp_byte);
	}
	digitalWrite(ChipSelPin1, HIGH);
	// DEBUG_PRINTLN();
	return true; // end of writeDMPMemory reached
}

//***********************************************************//
boolean verifyDMPMemory()
{
	// - the value in 0x6D activates a specific bank in the DMP
	// - the value in 0x6E sets the read/write pointer to a specific startaddress within the specified DMP bank
	// - register 0x6F is the register from which to read or to which to write the data
	//   (after each r/w autoincrement address within the specified DMP bank starting from startaddress)

	// Serial.print("\tVerifying DMP memory.......... ");

	unsigned int i, j;
	byte dmp_byte, check_byte;
	boolean verification = true;

	// ### there are 8 DMP banks (numbers 0 to 7)

	// DMP banks 0 - 6 are completely read, all 256 bytes:
	for (i = 0; i < 7; i ++)
	{
		DEBUG_PRINT(">>> read bank "); DEBUG_PRINTLN(i);
		spi_writeReg(ChipSelPin1, 0x6D, i); // bank number  = i
		spi_writeReg(ChipSelPin1, 0x6E, 0); // startaddress = 0 so start reading every DMP bank from the beginning
		digitalWrite(ChipSelPin1, LOW);
		SPI.transfer(0x6F | 0x80); // 0x6F | 0x80 causes a "1" added as MSB to 0x6F to denote reading from reg i.s.o. writing to it

		for (j = 0; j < 256; j ++) // max. 256 bytes of data fit into one DMP bank
		{
			check_byte = pgm_read_byte(dmpMemory + (i * 256) + j);
			dmp_byte = SPI.transfer(0x00);
			if (dmp_byte != check_byte)
			{
				Serial.print("$$$ dmpMemory: byte verification error ");
				Serial.println(j);
				verification = false;
			}
		}
		digitalWrite(ChipSelPin1, HIGH);
		// DEBUG_PRINTLN();
	}

	// DMP bank 7 only read first 137 bytes:
	DEBUG_PRINTLN(">>> read bank 7");
	spi_writeReg(ChipSelPin1, 0x6D, 7); // bank number  = 7
	spi_writeReg(ChipSelPin1, 0x6E, 0);       // startaddress = 0 so start reading also this DMP bank from the beginning
	digitalWrite(ChipSelPin1, LOW);
	SPI.transfer(0x6F | 0x80); // 0x6F | 0x80 causes a "1" added as MSB to 0x6F to denote reading from reg i.s.o. writing to it

	for (j = 0; j < 137; j ++) // only 137 bytes of data into DMP bank 7
	{
		check_byte = pgm_read_byte(dmpMemory + (7 * 256) + j);
		dmp_byte = SPI.transfer(0x00);
		if (dmp_byte != check_byte)
		{
			Serial.println("$$$ dmpMemory: byte verification error 7");
			verification = false;
		}
	}
	digitalWrite(ChipSelPin1, HIGH);
	DEBUG_PRINTLN();

	// if (verification == true)  Serial.println("success!");
	// if (verification == false) Serial.println("FAILED!");

	return verification; // true if DMP correctly written, false if not
}

//***********************************************************//
boolean writeDMPConfig()
{
	byte progBuffer, success, special;
	unsigned int i, j;
	// config set dmpConfig is a long string of blocks with the following structure:
	// [bank] [offset] [length] [byte[0], byte[1], ..., byte[length]]
	byte bank, offset, length;

	// Serial.print("\tWriting   DMP configuration... ");

	for (i = 0; i < MPU6050_DMP_CONFIG_SIZE;)
	{
		bank   = pgm_read_byte(dmpConfig + i++); // pgm_read_byte() is a macro that reads a byte of data stored in a specified address(PROGMEM area)
		offset = pgm_read_byte(dmpConfig + i++);
		length = pgm_read_byte(dmpConfig + i++);

		if (length > 0) // regular block of data to write
		{
			DEBUG_PRINT("!! bank  : "); DEBUG_PRINTLNF(bank, HEX);
			spi_writeReg(ChipSelPin1, 0x6D, bank); // bank number  = bank
			DEBUG_PRINT("!! offset: "); DEBUG_PRINTLNF(offset, HEX);
			spi_writeReg(ChipSelPin1, 0x6E, offset);     // startaddress = offset from the beginning (0) of the bank
			DEBUG_PRINT("!! length: "); DEBUG_PRINTLNF(length, HEX);

			digitalWrite(ChipSelPin1, LOW);
			SPI.transfer(0x6F);

			for (j = 0; j < length; j++)
			{
				progBuffer = pgm_read_byte(dmpConfig + i + j);
				SPI.transfer(progBuffer);
				DEBUG_PRINTLNF(progBuffer, HEX);
			}

			digitalWrite(ChipSelPin1, HIGH);
			i = i + length;
		}

		else // length = 0; special instruction to write
		{
			// NOTE: this kind of behavior (what and when to do certain things)
			// is totally undocumented. This code is in here based on observed
			// behavior only, and exactly why (or even whether) it has to be here
			// is anybody's guess for now.
			special = pgm_read_byte(dmpConfig + i++);
			DEBUG_PRINTLN("!! Special command code ");
			DEBUG_PRINTF(special, HEX);
			DEBUG_PRINTLN(" found...");
			if (special == 0x01)
			{
				// enable DMP-related interrupts (ZeroMotion, FIFOBufferOverflow, DMP)
				spi_writeReg(ChipSelPin1, 0x38, 0x32); // write 00110010: ZMOT_EN, FIFO_OFLOW_EN, DMP_INT_EN true
				// by the way: this sets all other interrupt enables to false
				success = true;
			}
			else
			{
				// unknown other special command if this may be needed in the future, but for now this should not happen
				success = false;
			}
		}
	}

	// Serial.println("done.");

	return true;
}

//***********************************************************//
boolean verifyDMPConfig()
{
	byte check_byte, progBuffer, success, special;
	unsigned int i, j;
	// config set dmpConfig is a long string of blocks with the following structure:
	// [bank] [offset] [length] [byte[0], byte[1], ..., byte[length]]
	byte bank, offset, length;
	boolean verification = true;

	// Serial.print("\tVerifying DMP configuration... ");

	for (i = 0; i < MPU6050_DMP_CONFIG_SIZE;)
	{
		bank   = pgm_read_byte(dmpConfig + i++); // pgm_read_byte() is a macro that reads a byte of data stored in a specified address(PROGMEM area)
		offset = pgm_read_byte(dmpConfig + i++);
		length = pgm_read_byte(dmpConfig + i++);

		if (length > 0) // regular block of data to read
		{
			DEBUG_PRINT("!! bank  : "); DEBUG_PRINTLNF(bank, HEX);
			spi_writeReg(ChipSelPin1, 0x6D, bank); // bank number  = bank
			DEBUG_PRINT("!! offset: "); DEBUG_PRINTLNF(offset, HEX);
			spi_writeReg(ChipSelPin1, 0x6E, offset);     // startaddress = offset from the beginning (0) of the bank
			DEBUG_PRINT("!! length: "); DEBUG_PRINTLNF(length, HEX);

			digitalWrite(ChipSelPin1, LOW);
			SPI.transfer(0x6F | 0x80); // 0x6F | 0x80 causes a "1" added as MSB to 0x6F to denote reading from reg i.s.o. writing to it

			for (j = 0; j < length; j++)
			{
				progBuffer = pgm_read_byte(dmpConfig + i + j);
				check_byte = SPI.transfer(0x00);
				if (progBuffer != check_byte)
				{
					DEBUG_PRINTLN("$$$ dmpConfig: byte verification error");
					verification = false;
				}
			}

			digitalWrite(ChipSelPin1, HIGH);
			i = i + length;
		}

		else // length = 0; special instruction to write
		{
			// NOTE: this kind of behavior (what and when to do certain things)
			// is totally undocumented. This code is in here based on observed
			// behavior only, and exactly why (or even whether) it has to be here
			// is anybody's guess for now.
			special = pgm_read_byte(dmpConfig + i++);
			DEBUG_PRINT("!! Special command code ");
			DEBUG_PRINTF(special, HEX);
			DEBUG_PRINTLN(" found...");
			if (special == 0x01)
			{
				// enable DMP-related interrupts (ZeroMotion, FIFOBufferOverflow, DMP)
				// check_byte = SPIread(0x38, ChipSelPin1);  // shoudl read 00110010: ZMOT_EN, FIFO_OFLOW_EN, DMP_INT_EN true
				check_byte = spi_readReg(ChipSelPin1, 0x38);

				if (check_byte != 0x32)
				{
					DEBUG_PRINTLN("$$$ dmpConfig: byte verification error");
					verification = false;
				}
				success = true;
			}
			else
			{
				// unknown special command
				success = false;
			}
		}
	}

	if (verification == true)  //Serial.println("success!");
		if (verification == false) Serial.println("FAILED!");

	return verification; // true if DMP correctly written, false if not
}

//***********************************************************//
unsigned int writeDMPUpdates(unsigned int pos, byte update_number)
// process only one line from dmpUpdates each time writeDMPUpdates() is called
{
	// pos is the current reading position within dmpUpdates
	byte progBuffer, success;
	unsigned int j;
	// config set dmpUpdates is a long string of blocks with the following structure:
	// [bank] [offset] [length] [byte[0], byte[1], ..., byte[length]]
	byte bank, offset, length;

	// Serial.print("\tWriting   DMP update "); Serial.print(update_number); Serial.print("/7 ..... ");


	bank   = pgm_read_byte(dmpUpdates + pos++); // pgm_read_byte() is a macro that reads a byte of data stored in a specified address(PROGMEM area)
	offset = pgm_read_byte(dmpUpdates + pos++);
	length = pgm_read_byte(dmpUpdates + pos++);

	DEBUG_PRINT("!! bank  : "); DEBUG_PRINTLNF(bank, HEX);
	spi_writeReg(ChipSelPin1, 0x6D, bank); // bank number  = bank
	DEBUG_PRINT("!! offset: "); DEBUG_PRINTLNF(offset, HEX);
	spi_writeReg(ChipSelPin1, 0x6E, offset);     // startaddress = offset from the beginning (0) of the bank
	DEBUG_PRINT("!! length: "); DEBUG_PRINTLNF(length, HEX);

	digitalWrite(ChipSelPin1, LOW);
	SPI.transfer(0x6F);

	for (j = 0; j < length; j++)
	{
		progBuffer = pgm_read_byte(dmpUpdates + pos + j);
		SPI.transfer(progBuffer);
		DEBUG_PRINTLNF(progBuffer, HEX);
	}

	digitalWrite(ChipSelPin1, HIGH);
	pos = pos + length;
	DEBUG_PRINT("!! last position written: "); DEBUG_PRINTLN(pos);

	// Serial.println("done.");

	return pos; // return last used position in dmpUpdates: will be starting point for next call!
}

//***********************************************************//
unsigned int verifyDMPUpdates(unsigned int pos_verify, byte update_number)
// process only one line from dmpUpdates each time writeDMPUpdates() is called
{
	// pos_verify is the current verifying position within dmpUpdates
	byte check_byte, progBuffer, success;
	unsigned int j;
	// config set dmpUpdates is a long string of blocks with the following structure:
	// [bank] [offset] [length] [byte[0], byte[1], ..., byte[length]]
	byte bank, offset, length;
	boolean verification = true;

	// Serial.print("\tVerifying DMP update "); Serial.print(update_number); Serial.print("/7 ..... ");

	bank   = pgm_read_byte(dmpUpdates + pos_verify++); // pgm_read_byte() is a macro that reads a byte of data stored in a specified address(PROGMEM area)
	offset = pgm_read_byte(dmpUpdates + pos_verify++);
	length = pgm_read_byte(dmpUpdates + pos_verify++);

	DEBUG_PRINT("!! bank  : "); DEBUG_PRINTLNF(bank, HEX);
	spi_writeReg(ChipSelPin1, 0x6D, bank); // bank number  = bank
	DEBUG_PRINT("!! offset: "); DEBUG_PRINTLNF(offset, HEX);
	spi_writeReg(ChipSelPin1, 0x6E, offset);     // startaddress = offset from the beginning (0) of the bank
	DEBUG_PRINT("!! length: "); DEBUG_PRINTLNF(length, HEX);

	digitalWrite(ChipSelPin1, LOW);
	SPI.transfer(0x6F | 0x80); // 0x6F | 0x80 causes a "1" added as MSB to 0x6F to denote reading from reg i.s.o. writing to it

	for (j = 0; j < length; j++)
	{
		progBuffer = pgm_read_byte(dmpUpdates + pos_verify + j);
		check_byte = SPI.transfer(0x00);
		if (progBuffer != check_byte)
		{
			DEBUG_PRINTLN("$$$ dmpUpdates: byte verification error");
			verification = false;
		}
	}

	digitalWrite(ChipSelPin1, HIGH);
	pos_verify = pos_verify + length;
	DEBUG_PRINT("!! last position verified: "); DEBUG_PRINTLN(pos_verify);

	if (verification == true)  //Serial.println("success!");
		if (verification == false) Serial.println("FAILED!");
	//return verification; // true if DMP correctly written, false if not

	return pos_verify; // return last used position in dmpUpdates: will be starting point for next call!
}

//***********************************************************//
/** Get current FIFO buffer size.
 * This value indicates the number of bytes stored in the FIFO buffer. This
 * number is in turn the number of bytes that can be read from the FIFO buffer
 * and it is directly proportional to the number of samples available given the
 * set of sensor data bound to be stored in the FIFO (defined by register 35 and 36).
 * - return: Current FIFO buffer size
 */
unsigned int getFIFOCount(int ChipSelPin)
{
	// FIFO_COUNT should always be read in high-low order (0x72-0x73) in order to
	// guarantee that the most current FIFO Count value is read
	byte fifo_H = spi_readReg(ChipSelPin1, 0x72);
	byte fifo_L = spi_readReg(ChipSelPin1, 0x73);
	unsigned int two_bytes = (fifo_H << 8) | fifo_L;
	return two_bytes;
}

// #define MPU6050_RA_XG_OFFS_USRH     0x13 //[15:0] XG_OFFS_USR
// #define MPU6050_RA_XG_OFFS_USRL     0x14
// #define MPU6050_RA_YG_OFFS_USRH     0x15 //[15:0] YG_OFFS_USR
// #define MPU6050_RA_YG_OFFS_USRL     0x16
// #define MPU6050_RA_ZG_OFFS_USRH     0x17 //[15:0] ZG_OFFS_USR
// #define MPU6050_RA_ZG_OFFS_USRL     0x18

void setXGyroOffset(int16_t offset) {
	spi_writeReg(ChipSelPin1, 0x13, offset);
}

void setYGyroOffset(int16_t offset) {
	spi_writeReg(ChipSelPin1, 0x15, offset);
}

void setZGyroOffset(int16_t offset) {
	spi_writeReg(ChipSelPin1, 0x17, offset);
}
// ############################################################################################## //
// ################################ Main DMP initialize function ################################ //
// ############################################################################################## //
// If you like to know how it works, please read on. Otherwise, just FIRE AND FORGET ;-)
unsigned char dmpInitialize()
{
	//Reset
	spi_SetBits(ChipSelPin1, 0x6B, (1 << 7));	//PWR_MGMT_1    -- DEVICE_RESET 1
	// byte rev = spi_readReg(ChipSelPin1, 0x6B);
	// rev |= (1<<7);
	// spi_writeReg(ChipSelPin1, 0x6B, rev);	//PWR_MGMT_1    -- DEVICE_RESET 1

	delay(200);

	// Setting the SLEEP bit in the register puts the device into very low power
	// sleep mode. In this mode, only the serial interface and internal registers
	// remain active, allowing for a very low standby current. Clearing this bit
	// puts the device back into normal mode. To save power, the individual standby
	// selections for each of the gyros should be used if any gyro axis is not used
	// by the application.
	// disable sleep mode
	spi_ClrBits(ChipSelPin1, 0x6B, (1 << 6));// Important!!! If not disalbe sleep mode, verifying dmp memory will failed!
	// rev = spi_readReg(ChipSelPin1, 0x6B);
	// rev &= ~(1<<6);
	// spi_writeReg(ChipSelPin1, 0x6B, rev);	//


	// get MPU hardware revision
	// DEBUG_PRINTLN(F("Selecting user bank 16..."));
	// setMemoryBank(0x10, true, true, ChipSelPin1);
	// spi_writeReg(ChipSelPin1, 0x6D, 0x10 | 0x20 | 0x40);//0x10 | 0x20 | 0x40
	// DEBUG_PRINTLN(F("Selecting memory byte 6..."));
	// spi_writeReg(ChipSelPin1, 0x6E, 6);
	// DEBUG_PRINTLN(F("Checking hardware revision..."));
	// byte hwRevision = spi_readReg(ChipSelPin1, 0x6F);
	// DEBUG_PRINT(F("Revision @ user[16][6] = "));
	// DEBUG_PRINTLNF(hwRevision, HEX);
	// DEBUG_PRINTLN(F("Resetting memory bank selection to 0..."));
	// setMemoryBank(0, false, false, ChipSelPin1);
	// spi_writeReg(ChipSelPin1, 0x6D, 0);


	// check OTP bank valid
	DEBUG_PRINTLN(F("Reading OTP bank valid flag..."));
	// byte otpValid = SPIreadBit(0x00, 0, ChipSelPin1);
	byte otpValid = spi_readReg(ChipSelPin1, 0x00);
	otpValid = otpValid | 0x01;
	DEBUG_PRINT(F("OTP bank is "));
	DEBUG_PRINTLN((otpValid | 0x01) ? F("valid!") : F("invalid!"));

	// get X/Y/Z gyro offsets
	DEBUG_PRINTLN(F("Reading gyro offset TC values..."));
	// byte xgOffsetTC = SPIreadBits(0x01, 6, 6, ChipSelPin1); // [7] PWR_MODE, [6:1] XG_OFFS_TC, [0] OTP_BNK_VLD
	byte xgOffsetTC = spi_readReg(ChipSelPin1, 0x00); // [7] PWR_MODE, [6:1] XG_OFFS_TC, [0] OTP_BNK_VLD
	xgOffsetTC = (xgOffsetTC & 0x7E) >> 1;
	// byte ygOffsetTC = SPIreadBits(0x02, 6, 6, ChipSelPin1); // [7] PWR_MODE, [6:1] YG_OFFS_TC, [0] OTP_BNK_VLD
	byte ygOffsetTC = spi_readReg(ChipSelPin1, 0x01); // [7] PWR_MODE, [6:1] XG_OFFS_TC, [0] OTP_BNK_VLD
	ygOffsetTC = (ygOffsetTC & 0x7E) >> 1;
	// byte zgOffsetTC = SPIreadBits(0x03, 6, 6, ChipSelPin1); // [7] PWR_MODE, [6:1] ZG_OFFS_TC, [0] OTP_BNK_VLD
	byte zgOffsetTC = spi_readReg(ChipSelPin1, 0x02); // [7] PWR_MODE, [6:1] XG_OFFS_TC, [0] OTP_BNK_VLD
	zgOffsetTC = (zgOffsetTC & 0x7E) >> 1;

	DEBUG_PRINT("X gyro offset = 0x");
	DEBUG_PRINTLN(xgOffsetTC);
	DEBUG_PRINT("Y gyro offset = 0x");
	DEBUG_PRINTLN(ygOffsetTC);
	DEBUG_PRINT("Z gyro offset = 0x");
	DEBUG_PRINTLN(zgOffsetTC);


	// load DMP code into memory banks
	DEBUG_PRINT(F("########################### 2. Writing DMP code to MPU memory banks ("));
	DEBUG_PRINT(MPU6050_DMP_CODE_SIZE);
	DEBUG_PRINTLN(F(" bytes)"));
	if (writeDMPMemory())
	{
		// DEBUG_PRINTLN(F("########################### Success! DMP code written but not verified."));

		DEBUG_PRINTLN(F("########################### 3. Verify DMP code..."));
		verifyDMPMemory();

		// digitalWrite(BLUE_LED_PIN, LOW); // shows end of write DMP memory
		delay(200); // time to see the LED blink




		// write DMP configuration
		DEBUG_PRINT(F("########################### 4. Writing DMP configuration to MPU memory banks ("));
		DEBUG_PRINT(MPU6050_DMP_CONFIG_SIZE);
		DEBUG_PRINTLN(F(" bytes in config def)"));
		if (writeDMPConfig())
		{
			// DEBUG_PRINTLN(F("########################### Success! DMP configuration written but not verified."));

			DEBUG_PRINTLN(F("########################### 5. Verify DMP configuration..."));
			verifyDMPConfig();


			// digitalWrite(BLUE_LED_PIN, HIGH); // shows start of write DMP configuration
			delay(200); // time to see the LED blink

			DEBUG_PRINTLN(F("Setting clock source to Z Gyro..."));
			// SPIwriteBits(0x6B, 2, 3, 0x03, ChipSelPin1); // CLKSEL[2:0] = 011 = PLL with Z axis gyroscope reference
			spi_SetBits(ChipSelPin1, 0x6B, (1 << 0 | 1 << 1) );

			DEBUG_PRINTLN(F("Setting DMP and FIFO_OFLOW interrupts enabled..."));
			// SPIwrite(0x38, 0x12, ChipSelPin1); // INT_ENABLE = 00010010 = FIFO_OFLOW_EN & DMP_INT_EN
			spi_writeReg(ChipSelPin1, 0x38, 0x12);// INT_ENABLE = 00010010 = FIFO_OFLOW_EN & DMP_INT_EN

			// register INT_ENABLE 0x38:
			// bit 0 DATA_RDY_EN      0x01
			// bit 1 DMP_INT_EN       0x02 (undocumented) - enabling this bit also enables DATA_RDY_EN it seems
			// bit 2 UNKNOWN_INT_EN   0x04 (undocumented)
			// bit 3 I2C_MST_INT_EN   0x08
			// bit 4 FIFO_OFLOW_EN    0x10
			// bit 5 ZMOT_EN          0x20 (undocumented)
			// bit 6 MOT_EN           0x40
			// bit 7 FF_EN            0x80 (undocumented)

			// register INT_STATUS 0x3A:
			// bit 0 DATA_RDY_INT     0x01
			// bit 1 DMP_INT          0x02 (undocumented)
			// bit 2 UNKNOWN_INT      0x04 (undocumented)
			// bit 3 I2C_MST_INT      0x08
			// bit 4 FIFO_OFLOW_INT   0x10
			// bit 5 ZMOT_INT         0x20 (undocumented)
			// bit 6 MOT_INT          0x40
			// bit 7 FF_INT           0x80 (undocumented)

			// [0x19] SMPLRT_DIV
			DEBUG_PRINTLN(F("Setting sample rate to 200Hz..."));
			//setRate(4); // 1kHz / (1 + 4) = 200 Hz (when DLPF_CFG enabled [1 to 6] - true, see below)
			spi_writeReg(ChipSelPin1, 0x19, 4); // SMPLRT_DIV[7:0] = 4 (ok)

			// WHY? HOW to use FSYNC?
			// [0x1A] CONFIG - FSYNC input not connnected on ArduIMU+ V3, but connected on APM, here the FYSNC is not used
			DEBUG_PRINTLN(F("Disable external frame synchronization..."));
			spi_ClrBits(ChipSelPin1, 0x1A, (1 << 3 | 1 << 4 | 1 << 5)); // EXT_SYNC_SET[2:0] = 000 = input disabled
			DEBUG_PRINTLN(F("Setting DLPF bandwidth to 42Hz..."));
			spi_SetBits(ChipSelPin1, 0x1A, (1 << 0 | 1 << 1)); // DLPF_CFG[2:0] = 011 = accel 44 Hz gyro 42 Hz
			spi_ClrBits(ChipSelPin1, 0x1A, (1 << 2));

			// [0x1B] GYRO_CONFIG
			DEBUG_PRINTLN(F("Setting gyro sensitivity to +/- 2000 deg/sec..."));
			spi_SetBits(ChipSelPin1, 0x1B, (1 << 3 | 1 << 4)); // FS_SEL[1:0] = 11 = +/- 2000 deg/s

			// [0x1C] ACCEL_CONFIG
			DEBUG_PRINTLN(F("Setting accelerometer full scale range to +/- 2 g..."));
			spi_ClrBits(ChipSelPin1, 0x1C, (1 << 3 | 1 << 4)); // AFS_SEL[1:0] = 00 = +/- 2 g

			// [0x70] DMP_CFG_1 and [0x71] DMP_CFG_2
			DEBUG_PRINTLN(F("Setting DMP configuration bytes (function unknown)..."));
			spi_writeReg(ChipSelPin1, 0x70, 0x03); // DMP related register
			spi_writeReg(ChipSelPin1, 0x71, 0x00); // DMP related register

			// [0x00] AUX_VDDIO
			DEBUG_PRINTLN(F("Clearing OTP Bank flag..."));
			spi_ClrBits(ChipSelPin1, 0x00, (1 << 0)); // [0] OTP_BNK_VLD

			// WHY? Read out and write back?
			// enabling this part causes misalignment and drift of x, y and z axis
			// relative to APM/MPU-6000 x, y and z axis
			// DEBUG_PRINTLN(F("Setting X/Y/Z gyro offset TCs to previous values..."));
			// SPIwriteBits(0x00, 6, 6, xgOffsetTC, ChipSelPin1);
			// SPIwriteBits(0x01, 6, 6, ygOffsetTC, ChipSelPin1);
			// SPIwriteBits(0x02, 6, 6, zgOffsetTC, ChipSelPin1);

			// Serial.println("Setting X/Y/Z gyro user offsets to zero...");
			// setXGyroOffset(0);
			// setYGyroOffset(0);
			// setZGyroOffset(0);

			DEBUG_PRINTLN(F("###################### 6. Writing final memory update 1/7 (function unknown)..."));
			byte update_number = 1;      // holds update number for user information
			unsigned int pos = 0;        // pos        is the current reading position within dmpUpdates; this is the first call; set pos        = 0 only once!
			pos = writeDMPUpdates(pos, update_number);
			unsigned int pos_verify = 0; // pos_verify is the current reading position within dmpUpdates; this is the first call; set pos_verify = 0 only once!
			pos_verify = verifyDMPUpdates(pos_verify, update_number);

			DEBUG_PRINTLN(F("Writing final memory update 2/7 (function unknown)..."));
			update_number ++;
			pos = writeDMPUpdates(pos, update_number);
			pos_verify = verifyDMPUpdates(pos_verify, update_number);

			DEBUG_PRINTLN(F("Resetting FIFO..."));
			spi_ClrBits(ChipSelPin1, 0x6A, (1 << 6)); // FIFO_EN = 0 = disable
			spi_SetBits(ChipSelPin1, 0x6A, (1 << 2)); // FIFO_RESET = 1 = reset (ok) only when FIFO_EN = 0
			spi_SetBits(ChipSelPin1, 0x6A, (1 << 6)); // FIFO_EN = 1 = enable

			// Get current FIFO buffer size.
			// This value indicates the number of bytes stored in the FIFO buffer. This
			// number is in turn the number of bytes that can be read from the FIFO buffer
			// and it is directly proportional to the number of samples available given the
			// set of sensor data bound to be stored in the FIFO (register 35 and 36).
			DEBUG_PRINTLN(F("Reading FIFO count..."));
			unsigned int fifoCount = getFIFOCount(ChipSelPin1);

			// just after FIFO reset so count probably 0
			DEBUG_PRINT(F("Current FIFO count = "));
			DEBUG_PRINTLN(fifoCount);
			spi_readBytes(ChipSelPin1, 0x74, fifoCount, fifoBuffer);

			DEBUG_PRINTLN(F("Setting motion detection threshold to 2..."));
			spi_writeReg(ChipSelPin1, 0x1F, 2);// MOT_THR[7:0] = 2

			DEBUG_PRINTLN(F("Setting zero-motion detection threshold to 156..."));
			spi_writeReg(ChipSelPin1, 0x21, 156); // detection threshold for Zero Motion interrupt generation

			DEBUG_PRINTLN(F("Setting motion detection duration to 80..."));
			spi_writeReg(ChipSelPin1, 0x20, 80); // duration counter threshold for Motion interrupt generation. The duration counter ticks at 1 kHz, therefore MOT_DUR has a unit of 1 LSB = 1 ms

			DEBUG_PRINTLN(F("Setting zero-motion detection duration to 0..."));
			spi_writeReg(ChipSelPin1, 0x22, 0);// duration counter threshold for Zero Motion interrupt generation. The duration counter ticks at 16 Hz, therefore ZRMOT_DUR has a unit of 1 LSB = 64 ms

			DEBUG_PRINTLN(F("Resetting FIFO..."));
			spi_ClrBits(ChipSelPin1, 0x6A, (1 << 6));// FIFO_EN = 0 = disable
			spi_SetBits(ChipSelPin1, 0x6A, (1 << 2));// FIFO_RESET = 1 = reset (ok) only when FIFO_EN = 0

			DEBUG_PRINTLN(F("Enabling FIFO..."));
			spi_SetBits(ChipSelPin1, 0x6A, (1 << 6));// FIFO_EN = 1 = enable

			DEBUG_PRINTLN(F("Enabling DMP..."));
			spi_SetBits(ChipSelPin1, 0x6A, (1 << 7));// USER_CTRL_DMP_EN

			DEBUG_PRINTLN(F("Resetting DMP..."));
			spi_SetBits(ChipSelPin1, 0x6A, (1 << 3));// Reset DMP

			DEBUG_PRINTLN(F("Writing final memory update 3/7 (function unknown)..."));
			update_number ++;
			pos = writeDMPUpdates(pos, update_number);
			pos_verify = verifyDMPUpdates(pos_verify, update_number);

			DEBUG_PRINTLN(F("Writing final memory update 4/7 (function unknown)..."));
			update_number ++;
			pos = writeDMPUpdates(pos, update_number);
			pos_verify = verifyDMPUpdates(pos_verify, update_number);

			DEBUG_PRINTLN(F("Writing final memory update 5/7 (function unknown)..."));
			update_number ++;
			pos = writeDMPUpdates(pos, update_number);
			pos_verify = verifyDMPUpdates(pos_verify, update_number);

			//delay(50); // may be used as test just to see if number of FIFO bytes changes

			DEBUG_PRINTLN(F("Waiting for FIFO count > 2..."));
			while ((fifoCount = getFIFOCount(ChipSelPin1)) < 3);

			/* switched off, may crash the sketch (FIFO contents not used here anyway)
			// 1st read FIFO
			DEBUG_PRINT(F("Current FIFO count = "));
			DEBUG_PRINTLN(fifoCount);
			DEBUG_PRINTLN(F("Reading FIFO data..."));
			Serial.println("Reading FIFO data 1st time...");
			spi_readBytes(ChipSelPin1, 0x74, fifoCount, fifoBuffer);
			for(int i=0; i<1024; i++){
				Serial.print(i);
				Serial.print("= ");
				Serial.println(fifoBuffer[i]);
			}
			*/

			DEBUG_PRINTLN(F("Reading interrupt status..."));
			byte mpuIntStatus = spi_readReg(ChipSelPin1, 0x3A);

			DEBUG_PRINT(F("Current interrupt status = "));
			DEBUG_PRINTLNF(mpuIntStatus, HEX);

			// Jeff Rowberg's code had a read statement here... I suppose that must be a write statement!
			//DEBUG_PRINTLN(F("Reading final memory update 6/7 (function unknown)..."));
			//for (j = 0; j < 4 || j < dmpUpdate[2] + 3; j++, pos++) dmpUpdate[j] = pgm_read_byte(&dmpUpdates[pos]);
			//readMemoryBlock(dmpUpdate + 3, dmpUpdate[2], dmpUpdate[0], dmpUpdate[1]);
			DEBUG_PRINTLN(F("Writing final memory update 6/7 (function unknown)..."));
			update_number ++;
			pos = writeDMPUpdates(pos, update_number);
			pos_verify = verifyDMPUpdates(pos_verify, update_number);

			DEBUG_PRINTLN(F("Waiting for FIFO count > 2..."));
			while ((fifoCount = getFIFOCount(ChipSelPin1)) < 3);

			DEBUG_PRINT(F("Current FIFO count="));
			DEBUG_PRINTLN(fifoCount);

			/* switched off, may crash the sketch (FIFO contents not used here anyway)
			// 2nd read FIFO
			//DEBUG_PRINTLN(F("Reading FIFO data..."));
			Serial.println("Reading FIFO data 2nd time...");
			spi_readBytes(0x74, fifoCount, fifoBuffer, ChipSelPin1);
			*/

			DEBUG_PRINTLN(F("Reading interrupt status..."));
			mpuIntStatus = spi_readReg(ChipSelPin1, 0x3A);

			DEBUG_PRINT(F("Current interrupt status="));
			DEBUG_PRINTLNF(mpuIntStatus, HEX);

			DEBUG_PRINTLN(F("Writing final memory update 7/7 (function unknown)..."));
			update_number ++;
			pos = writeDMPUpdates(pos, update_number);
			pos_verify = verifyDMPUpdates(pos_verify, update_number);

			DEBUG_PRINTLN(F("DMP is good to go! Finally."));

			DEBUG_PRINTLN(F("Disabling DMP (you turn it on later)..."));
			spi_ClrBits(ChipSelPin1, 0x6A, (1 << 7)); // USER_CTRL_DMP_EN

			DEBUG_PRINTLN(F("Resetting FIFO and clearing INT status one last time..."));
			//SPIwriteBit(0x6A, 6, false, ChipSelPin1); // FIFO_EN = 0 = disable
			// SPIwriteBit(0x6A, 2, true, ChipSelPin1); // FIFO_RESET = 1 = reset (ok) only when FIFO_EN = 0
			spi_SetBits(ChipSelPin1, 0x6A, (1 << 2));
			//SPIwriteBit(0x6A, 6, true, ChipSelPin1); // FIFO_EN = 1 = enable
			spi_readReg(ChipSelPin1, 0x3A); // reading the register will clear all INT bits

		}
		else
		{
			DEBUG_PRINTLN(F("ERROR! DMP configuration verification failed."));
			return 2; // configuration block loading failed
		}

	}
	else
	{
		DEBUG_PRINTLN(F("ERROR! DMP code verification failed."));
		return 1; // main binary block loading failed
	}

	delay(200); // time to see the LED blink

	// Serial.println("Digital Motion Processor (DMP) initializing done.");

	// Kalman init
	kalmanX.setAngle(0);
	kalmanY.setAngle(0);
	kalmanZ.setAngle(0);
	timer = micros();

	return 0; // success


}

unsigned int mpu_get() {
	if (mpuInterrupt) {

		// there has just been an interrupt, so reset the interrupt flag, then get INT_STATUS byte
		mpuInterrupt = false;
		// byte mpuIntStatus = SPIread(0x3A, ChipSelPin1); // by reading INT_STATUS register, all interrupts are cleared
		byte mpuIntStatus = spi_readReg(ChipSelPin1, 0x3A); // by reading INT_STATUS register, all interrupts are cleared

		// get current FIFO count
		fifoCount = getFIFOCount(ChipSelPin1);
		// Serial.print("DMP interrupt! FIFO count = ");
		// Serial.println(fifoCount);

		// check for FIFO overflow (this should never happen unless our code is too inefficient or DEBUG output delays code too much)
		// if ((mpuIntStatus & 0x10) || fifoCount == 1008)
		if ((mpuIntStatus & 0x10) || fifoCount >= 1008) // Change to >= 1008
			// mpuIntStatus & 0x10 checks register 0x3A for FIFO_OFLOW_INT
			// the size of the FIFO buffer is 1024 bytes, but max. set to 1008 so after 24 packets of 42 bytes
			// the FIFO is reset, otherwise the last FIFO reading before reaching 1024 contains only 16 bytes
			// and can/will produces output value miscalculations
		{
			// reset so we can continue cleanly
			//SPIwriteBit(0x6A, 6, false, ChipSelPin1); // FIFO_EN = 0 = disable
			// SPIwriteBit(0x6A, 2, true, ChipSelPin1); // FIFO_RESET = 1 = reset (ok) only when FIFO_EN = 0
			spi_SetBits(ChipSelPin1, 0x6A, (1 << 2));
			//SPIwriteBit(0x6A, 6, true, ChipSelPin1); // FIFO_EN = 1 = enable

			// digitalWrite(BLUE_LED_PIN, HIGH); // shows FIFO overflow without disturbing output with message
			// Serial.println("FIFO overflow! FIFO resetted to continue cleanly.");
		}

		// otherwise, check for DMP data ready interrupt (this should happen frequently)
		else if (mpuIntStatus & 0x02)
			// mpuIntStatus & 0x02 checks register 0x3A for (undocumented) DMP_INT
		{

			// wait for correct available data length, should be a VERY short wait
			while (fifoCount < packetSize) fifoCount = getFIFOCount(ChipSelPin1);

			// digitalWrite(BLUE_LED_PIN, LOW); // LED off again now that FIFO overflow is resolved

			// read a packet from FIFO
			// SPIreadBytes(0x74, packetSize, fifoBuffer, ChipSelPin1);
			spi_readBytes(ChipSelPin1, 0x74, packetSize, fifoBuffer);

			// verify contents of fifoBuffer before use:
			// # ifdef DEBUG
			// 		for (byte n = 0 ; n < packetSize; n ++)
			// 		{
			// 			Serial.print("\tfifoBuffer["); Serial.print(n); Serial.print("]\t: "); Serial.println(fifoBuffer[n], HEX);
			// 		}
			// # endif

			// track FIFO count here in case there is more than one packet (each of 42 bytes) available
			// (this lets us immediately read more without waiting for an interrupt)
			fifoCount = fifoCount - packetSize;


			// ============================================================================================== //
			// >>>>>>>>> - from here the 42 FIFO bytes from the MPU-6000 can be used to generate output >>>>>>>>
			// >>>>>>>>> - this would be the place to add your own code into                            >>>>>>>>
			// >>>>>>>>> - of course all the normal MPU-6000 registers can be used here too             >>>>>>>>
			// ============================================================================================== //

			// get the quaternion values from the FIFO - needed for Euler and roll/pitch/yaw angle calculations
			int raw_q_w = ((fifoBuffer[0] << 8)  + fifoBuffer[1]);  // W
			int raw_q_x = ((fifoBuffer[4] << 8)  + fifoBuffer[5]);  // X
			int raw_q_y = ((fifoBuffer[8] << 8)  + fifoBuffer[9]);  // Y
			int raw_q_z = ((fifoBuffer[12] << 8) + fifoBuffer[13]); // Z
			float q_w = raw_q_w / 16384.0f;
			float q_x = raw_q_x / 16384.0f;
			float q_y = raw_q_y / 16384.0f;
			float q_z = raw_q_z / 16384.0f;

// #ifdef OUTPUT_RAW_GYRO
			// print gyroscope values from fifoBuffer
			GyroX = ((fifoBuffer[16] << 8) + fifoBuffer[17]);
			GyroY = ((fifoBuffer[20] << 8) + fifoBuffer[21]);
			GyroZ = ((fifoBuffer[24] << 8) + fifoBuffer[25]);
// #endif

// #ifdef OUTPUT_READABLE_ROLLPITCHYAW
			// display Euler angles in degrees

			// dmpGetGravity
			float grav_x = 2 * ((q_x * q_z) - (q_w * q_y));
			float grav_y = 2 * ((q_w * q_x) + (q_y * q_z));
			float grav_z = (q_w * q_w) - (q_x * q_x) - (q_y * q_y) + (q_z * q_z);

			// pitch: (nose up/down, about Y axis)
			rpy_pit = atan(grav_y / (sqrt((grav_x * grav_x) + (grav_z * grav_z))));
			// roll: (tilt left/right, about X axis)
			rpy_rol = atan(grav_x / (sqrt((grav_y * grav_y) + (grav_z * grav_z))));
			// yaw: (rotate around Z axis)
			rpy_yaw = atan2((2 * q_x * q_y) - (2 * q_w * q_z), (2 * q_w * q_w) + (2 * q_x * q_x) - 1);

			rpy_pit = - (rpy_pit * 180 / M_PI);
			rpy_rol = rpy_rol * 180 / M_PI;
			kal_yaw = rpy_yaw * 180 / M_PI;
			// kal_yaw = map(rpy_yaw, -180, 180, 0, 360);

			//Kalman cal
			double dt = (double)(micros() - timer) / 1000000;
			timer = micros();
			double gyroXrate = GyroX / 131.0; // Convert to deg/s
			double gyroYrate = GyroY / 131.0; // Convert to deg/s
			double gyroZrate = GyroZ / 131.0; // Convert to deg/s
			kal_rol = kalmanX.getAngle(rpy_rol, gyroXrate, dt);
			kal_pit = kalmanY.getAngle(rpy_pit, gyroYrate, dt);
			// kal_yaw = kalmanZ.getAngle(rpy_yaw, gyroZrate, dt);

// #endif

#if 0
#ifdef OUTPUT_RAW_ACCEL
			// print accelerometer values from fifoBuffer
			int AcceX = ((fifoBuffer[28] << 8) + fifoBuffer[29]);
			int AcceY = ((fifoBuffer[32] << 8) + fifoBuffer[33]);
			int AcceZ = ((fifoBuffer[36] << 8) + fifoBuffer[37]);
			Serial.print("Raw acceleration ax, ay, az [8192 = 1 g]: "); Serial.print("\t\t");
			Serial.print  (AcceX); Serial.print("\t");
			Serial.print  (AcceY); Serial.print("\t");
			Serial.println(AcceZ);
#endif

#ifdef OUTPUT_RAW_ACCEL_G
			// same as OUTPUT_RAW_ACCEL but recalculated to g-force values
			int AcceX = ((fifoBuffer[28] << 8) + fifoBuffer[29]);
			int AcceY = ((fifoBuffer[32] << 8) + fifoBuffer[33]);
			int AcceZ = ((fifoBuffer[36] << 8) + fifoBuffer[37]);
			float Ax = AcceX / 8192.0f; // calculate g-value
			float Ay = AcceY / 8192.0f; // calculate g-value
			float Az = AcceZ / 8192.0f; // calculate g-value
			Serial.print("Raw acceleration ax, ay, az [g]: "); Serial.print("\t\t\t");
			Serial.print  (Ax, 3); Serial.print("\t");
			Serial.print  (Ay, 3); Serial.print("\t");
			Serial.println(Az, 3);
#endif

#ifdef OUTPUT_RAW_ANGLES
			// print calculated angles for roll and pitch from the raw acceleration components
			// (yaw is undetermined here, this needs the use of the quaternion - see further on)
			int AcceX = ((fifoBuffer[28] << 8) + fifoBuffer[29]);
			int AcceY = ((fifoBuffer[32] << 8) + fifoBuffer[33]);
			int AcceZ = ((fifoBuffer[36] << 8) + fifoBuffer[37]);
			// atan2 outputs the value of -pi to pi (radians) - see http://en.wikipedia.org/wiki/Atan2
			// We then convert it to 0 to 2 pi and then from radians to degrees - in the end it's 0 - 360 degrees
			float ADegX = (atan2(AcceY, AcceZ) + PI) * RAD_TO_DEG;
			float ADegY = (atan2(AcceX, AcceZ) + PI) * RAD_TO_DEG;
			Serial.print("Calculated angle from raw acceleration - roll, pitch and yaw [degrees]: ");
			Serial.print(ADegX); Serial.print("\t");
			Serial.print(ADegY); Serial.print("\t");
			Serial.println("undetermined");
#endif


#ifdef OUTPUT_TEMPERATURE
			// print calculated temperature from standard registers (not available in fifoBuffer)
			// the chip temperature may be used for correction of the temperature sensitivity of the
			// accelerometer and the gyroscope - not done in this sketch
			byte Temp_Out_H = spi_readReg(ChipSelPin1, 0x41);
			byte Temp_Out_L = spi_readReg(ChipSelPin1, 0x42);
			int TemperatureRaw = Temp_Out_H << 8 | Temp_Out_L;
			float Temperature = (TemperatureRaw / 340.00) + 36.53; // formula from datasheet chapter 4.19
			Serial.print("Chip temperature for corrections [deg. Celsius]: ");
			Serial.println(Temperature, 2);
			delay(1000);
#endif

#ifdef OUTPUT_READABLE_QUATERNION
			Serial.print("Quaternion qw, qx, qy, qz [-1 to +1]: "); Serial.print("\t");
			Serial.print  (q_w); Serial.print("\t");
			Serial.print  (q_x); Serial.print("\t");
			Serial.print  (q_y); Serial.print("\t");
			Serial.println(q_z);
#endif

#ifdef OUTPUT_READABLE_EULER
			// calculate Euler angles
			// http://en.wikipedia.org/wiki/Atan2
			// http://en.wikipedia.org/wiki/Sine (-> Inverse)
			float euler_x = atan2((2 * q_y * q_z) - (2 * q_w * q_x), (2 * q_w * q_w) + (2 * q_z * q_z) - 1); // phi
			float euler_y = -asin((2 * q_x * q_z) + (2 * q_w * q_y));                                        // theta
			float euler_z = atan2((2 * q_x * q_y) - (2 * q_w * q_z), (2 * q_w * q_w) + (2 * q_x * q_x) - 1); // psi
			euler_x = euler_x * 180 / M_PI; // angle in degrees -180 to +180
			euler_y = euler_y * 180 / M_PI; // angle in degrees
			euler_z = euler_z * 180 / M_PI; // angle in degrees -180 to +180
#endif
#endif


#ifdef OUTPUT_TEAPOT
			// display quaternion values in InvenSense Teapot demo format:
			teapotPacket[2] = fifoBuffer[0];
			teapotPacket[3] = fifoBuffer[1];
			teapotPacket[4] = fifoBuffer[4];
			teapotPacket[5] = fifoBuffer[5];
			teapotPacket[6] = fifoBuffer[8];
			teapotPacket[7] = fifoBuffer[9];
			teapotPacket[8] = fifoBuffer[12];
			teapotPacket[9] = fifoBuffer[13];
			Serial.write(teapotPacket, 14);
			teapotPacket[11]++; // packetCount, loops at 0xFF on purpose
#endif



		}
	}
}